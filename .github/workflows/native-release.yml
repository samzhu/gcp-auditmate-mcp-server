name: Build Native, Publish Release & Pages


on:
  push:
    branches: # 當推送到 main 分支時自動觸發
      - main
  workflow_dispatch:  # 允許從 GitHub 界面手動觸發


# 設定必要的權限
permissions:
  contents: write  # 允許建立 release
  pages: write     # 允許部署 GitHub Pages
  id-token: write  # 用於 GitHub Pages 部署


jobs:
  build-and-release: # 第一個任務: 構建原生執行檔
    # 矩陣策略設置: 同時構建 Intel 和 ARM 版本
    strategy:
      matrix:
        arch: [intel]  # 目前只定義 Intel 架構，未來可以添加其他架構
        include:
          # Intel 設置
          - arch: intel
            runner: macos-13  # 使用 macOS 13 (Intel) 的運行環境
            target_platform: darwin-x86_64  # GraalVM 目標平台
            artifact_name: gcp-auditmate-mcp-server-darwin-x86_64  # 產物命名與 target_platform 一致
            memory_options: "-Xmx12g -XX:MaxMetaspaceSize=1g"
            build_options: ""
          # ARM 設置
          # - arch: arm
          #   runner: macos-latest  # 使用 macOS-latest (ARM 架構，僅 7GB 記憶體)
          #   target_platform: darwin-aarch64  # GraalVM 目標平台
          #   artifact_name: gcp-auditmate-mcp-server-darwin-aarch64  # 產物命名與 target_platform 一致
          #   memory_options: "-Xmx5g -XX:MaxMetaspaceSize=512m"
          #   build_options: "-H:+PrintAnalysisCallTree -H:+PrintImageHeapPartitionSizes --no-fallback"

    # 根據矩陣變量選擇對應的運行環境
    runs-on: ${{ matrix.runner }}

    steps:
      # 第1步: 檢出代碼庫
      - name: Checkout
        uses: actions/checkout@v4

      # 第2步: 設置 GraalVM 環境
      - name: Setup GraalVM with Java 21
        uses: graalvm/setup-graalvm@v1
        with:
          java-version: '21'
          distribution: 'graalvm'

      # 第3步: 釋放系統資源
      - name: Free System Resources for ARM build
        if: matrix.arch == 'arm'
        run: |
          echo "Available memory before cleanup:"
          vm_stat || top -l 1 | grep PhysMem
          # 釋放 macOS 上的記憶體
          sudo purge
          echo "Available memory after cleanup:"
          vm_stat || top -l 1 | grep PhysMem
          # 停止不必要的服務
          brew services list || true
          # 顯示環境信息
          java -version
          echo "Processor info:"
          sysctl -n machdep.cpu.brand_string || system_profiler SPHardwareDataType | grep Chip

      # 第4步: 創建 GraalVM 配置文件
      # 這些配置對於正確構建原生執行檔非常重要，特別是針對使用到 AWT/Java2D 等需要特殊處理的功能
      - name: Create GraalVM Configuration Files
        run: |
          mkdir -p src/main/resources/META-INF/native-image
          
          # 創建 native-image.properties 配置文件
          cat > src/main/resources/META-INF/native-image/native-image.properties << EOF
          Args = -H:+UnlockExperimentalVMOptions \\
                 -H:+ReportExceptionStackTraces \\
                 -H:+AllowDeprecatedInitializeAllClassesAtBuildTime \\
                 --initialize-at-run-time=java.awt.Toolkit \\
                 --initialize-at-run-time=org.apache.poi.ss.format.CellFormatPart \\
                 --initialize-at-run-time=java.awt \\
                 --initialize-at-run-time=sun.awt \\
                 --initialize-at-run-time=sun.font \\
                 --initialize-at-run-time=sun.java2d \\
                 --initialize-at-run-time=sun.font.FontDesignMetrics \\
                 --initialize-at-run-time=java.awt.image,java.lang.Math.PowCache \\
                 --initialize-at-run-time=org.apache.poi.util.RandomSingleton \\
                 --initialize-at-run-time=org.apache.poi.hpsf.PropertySet \\
                 --initialize-at-run-time=org.apache.poi.util.ChainedProperties \\
                 --initialize-at-run-time=org.apache.poi.ss.util.SheetUtil \\
                 --initialize-at-run-time=org.apache.poi.util \\
                 --initialize-at-run-time=io.grpc \\
                 --trace-class-initialization=java.awt.Toolkit,org.apache.poi.ss.format.CellFormatPart \\
                 -H:EnableURLProtocols=http,https \\
                 -H:+AddAllCharsets \\
                 -Djava.awt.headless=true \\
                 -Dapple.awt.headless=true \\
                 -Dorg.apache.poi.ss.disableAutoColumnWidth=true \\
                 -Dorg.apache.poi.ss.format.disable.color=true
          EOF

      # 第5步: 準備和預熱 Gradle
      - name: Prepare Gradle
        run: |
          ./gradlew clean
          ./gradlew --stop
          ./gradlew --status

      # 第6步: 構建原生執行檔
      # 使用 GraalVM 的 native-image 工具將 Java 應用程序編譯為特定平台的原生執行檔
      - name: Build Native Executable
        run: ./gradlew nativeCompile -x test --info
        env:
          # 設置 Java 工具選項，包括目標平台參數和記憶體配置
          JAVA_TOOL_OPTIONS: "${{ matrix.memory_options }} -Dnative-image.target-platform=${{ matrix.target_platform }} -Dnative-image.executor-thread-count=2 ${{ matrix.build_options }}"

      # 第7步: 確保執行檔有執行權限
      - name: Make MCP server executable
        run: chmod +x build/native/nativeCompile/gcp-auditmate-mcp-server

      # 第8步: 設置版本號
      - name: Set version
        run: |
          echo "VERSION=20250421.1" >> $GITHUB_ENV
          echo "RELEASE_TAG=v20250421.1" >> $GITHUB_ENV
          echo "RELEASE_NAME=Release v20250421.1" >> $GITHUB_ENV
      
      # 第9步: 準備發布文件
      - name: Prepare release files
        run: |
          mkdir -p release
          # 複製並重命名執行檔，根據架構命名
          cp build/native/nativeCompile/gcp-auditmate-mcp-server release/${{ matrix.artifact_name }}
          cd release
          # 創建包含執行檔的 zip 壓縮包
          zip -r ${{ matrix.artifact_name }}.zip ${{ matrix.artifact_name }}
      
      # 第10步: 上傳構建產物
      # 這些產物將在後續的 create-release 任務中使用
      - name: Upload artifacts
        uses: actions/upload-artifact@v4
        with:
          name: ${{ matrix.artifact_name }}
          path: |
            release/${{ matrix.artifact_name }}
            release/${{ matrix.artifact_name }}.zip

  # 第二個任務: 創建 GitHub Release
  # 此任務依賴於 build-and-release 任務完成
  create-release:
    needs: build-and-release
    runs-on: ubuntu-latest
    steps:
      # 第1步: 下載所有構建產物
      - name: Download all artifacts
        uses: actions/download-artifact@v4
        with:
          path: release
      
      # 第2步: 設置版本號
      # 注意: 這裡重複設置版本號，以確保在這個任務中也能訪問版本信息
      - name: Set version
        run: |
          echo "VERSION=20250421.1" >> $GITHUB_ENV
          echo "RELEASE_TAG=v20250421.1" >> $GITHUB_ENV
          echo "RELEASE_NAME=Release v20250421.1" >> $GITHUB_ENV
          echo "INTEL_ARTIFACT=gcp-auditmate-mcp-server-darwin-x86_64" >> $GITHUB_ENV
          echo "ARM_ARTIFACT=gcp-auditmate-mcp-server-darwin-aarch64" >> $GITHUB_ENV
      
      # 第3步: 列出下載的文件，方便調試
      - name: List downloaded files
        run: find release -type f
      
      # 第4步: 重新組織文件結構，準備發布
      - name: Reorganize files
        run: |
          mkdir -p combined_release
          cp release/${{ env.INTEL_ARTIFACT }}/${{ env.INTEL_ARTIFACT }} combined_release/
          cp release/${{ env.INTEL_ARTIFACT }}/${{ env.INTEL_ARTIFACT }}.zip combined_release/

      
      # 第5步: 創建 GitHub Release
      - name: Create Release
        uses: softprops/action-gh-release@v2
        with:
          tag_name: ${{ env.RELEASE_TAG }}
          name: ${{ env.RELEASE_NAME }}
          body: |
            GCP Auditmate MCP Server for Mac
            
            目前只提供:
            - Intel Mac (x86_64): ${{ env.INTEL_ARTIFACT }}
            
            Built on: ${{ github.event.repository.updated_at }}
            Commit: ${{ github.sha }}
          draft: false  # 設為 true 可以創建草稿 release
          prerelease: false  # 設為 true 可以標記為預發布版本
          files: |
            combined_release/${{ env.INTEL_ARTIFACT }}
            combined_release/${{ env.INTEL_ARTIFACT }}.zip
            # ARM 文件已被移除，未來添加其他架構時可以擴展此處

  # 第三個任務: 部署 GitHub Pages
  # 此任務依賴於 build-and-release 任務完成
  deploy-pages:
    needs: build-and-release
    runs-on: ubuntu-latest
    steps:
      # 第1步: 檢出代碼庫
      - name: Checkout
        uses: actions/checkout@v4
        
      # 第2步: 上傳靜態網站內容
      - name: Upload static site as artifact
        uses: actions/upload-pages-artifact@v3
        with:
          path: site  # 靜態網站內容所在的目錄

      # 第3步: 部署到 GitHub Pages
      - name: Deploy to GitHub Pages
        id: deployment
        uses: actions/deploy-pages@v4 